# frozen_string_literal: true

# Compiled API Controller for <%= api_name.classify %>
# Generated by GraphQL UI Layout Compile API Generator
# Services: <%= compile_services.map { |s| s[:name] }.join(', ') %>
# Endpoints: <%= compile_endpoints.map { |e| e[:name] }.join(', ') %>

module Api
  module <%= api_name.classify %>
    class CompiledController < ApplicationController
      include Api::Queryable
      include Api::Authorizable
      include Api::Cacheable
      include Api::Analytics
      include Api::Notifications
      include Api::FileUploads

      before_action :set_services
      before_action :authenticate_user!, except: [:health, :schema]

      # =============================================================================
      # SERVICE INSTANTIATION
      # =============================================================================

      private

      def set_services
        <% compile_services.each do |service| %>
        @<%= service[:name] %>_service = <%= service[:class] %>.new
        <% end %>
        @unified_service = Zeropoint::Services::UnifiedApiService.new
      end

      # =============================================================================
      # HEALTH & METADATA ENDPOINTS
      # =============================================================================

      def health
        services_status = {
          <% compile_services.each do |service| %>
          <%= service[:name] %>: @<%= service[:name] %>_service.backend_info,
          <% end %>
        }

        render json: {
          status: 'healthy',
          timestamp: Time.current.iso8601,
          version: '<%= api_version %>',
          services: services_status,
          features: <%= enabled_features %>,
          backends: <%= backend_configs %>
        }
      end

      def schema
        render json: {
          version: '<%= api_version %>',
          services: <%= compile_services %>,
          endpoints: <%= compile_endpoints %>,
          features: <%= enabled_features %>,
          documentation: '/docs/api/<%= api_name %>/compiled_api.md'
        }
      end

      # =============================================================================
      # UNIFIED CRUD ENDPOINTS
      # =============================================================================

      def index
        model = get_model_from_params
        params_with_user = query_params.merge(user: current_user)
        
        result = @unified_service.execute_query(model, params_with_user)
        
        render json: {
          data: serialize_data(result),
          pagination: pagination_metadata(result),
          meta: {
            total_count: result.total_count,
            filtered_count: result.count,
            search_applied: params[:search].present?,
            filters_applied: params[:filters].present?,
            services_used: ['unified_api']
          }
        }
      end

      def show
        record = find_record
        authorize_record(record, :read)
        
        # Try to get from cache first
        cached_data = @cache_service.get_cached("record:#{record.class.name}:#{record.id}")
        
        if cached_data
          render json: {
            data: cached_data,
            meta: { cached: true, last_modified: record.updated_at }
          }
        else
          data = serialize_data(record)
          @cache_service.cache("record:#{record.class.name}:#{record.id}", data)
          
          render json: {
            data: data,
            meta: { cached: false, last_modified: record.updated_at }
          }
        end
      end

      def create
        model = get_model_from_params
        result = @unified_service.create_record(model, create_params, current_user)
        
        if result[:success]
          # Track analytics
          @analytics_service.track_event('record_created', {
            model: model.name,
            id: result[:record].id,
            user_id: current_user.id
          })
          
          # Send notification if configured
          @notification_service.send_notification(current_user, 'record_created', {
            model: model.name,
            record_id: result[:record].id
          })
          
          render json: { data: serialize_data(result[:record]), message: result[:message] }, status: :created
        else
          render json: { errors: result[:errors] }, status: :unprocessable_entity
        end
      end

      def update
        record = find_record
        authorize_record(record, :update)
        
        result = @unified_service.update_record(record, update_params, current_user)
        
        if result[:success]
          # Track analytics
          @analytics_service.track_event('record_updated', {
            model: record.class.name,
            id: record.id,
            user_id: current_user.id
          })
          
          # Invalidate cache
          @cache_service.invalidate_cache("record:#{record.class.name}:#{record.id}")
          
          render json: { data: serialize_data(result[:record]), message: result[:message] }
        else
          render json: { errors: result[:errors] }, status: :unprocessable_entity
        end
      end

      def destroy
        record = find_record
        authorize_record(record, :destroy)
        
        result = @unified_service.delete_record(record, current_user)
        
        if result[:success]
          # Track analytics
          @analytics_service.track_event('record_deleted', {
            model: record.class.name,
            id: record.id,
            user_id: current_user.id
          })
          
          # Invalidate cache
          @cache_service.invalidate_cache("record:#{record.class.name}:#{record.id}")
          
          render json: { message: result[:message] }
        else
          render json: { errors: result[:errors] }, status: :unprocessable_entity
        end
      end

      # =============================================================================
      # SEARCH ENDPOINTS
      # =============================================================================

      <% if compile_services.any? { |s| s[:name] == 'search' } %>
      def search
        model = get_model_from_params
        search_term = params[:q]
        search_type = params[:type] || 'basic'
        
        if search_term.blank?
          render json: { errors: ['Search term is required'] }, status: :bad_request
          return
        end
        
        case search_type
        when 'basic'
          result = @search_service.search(model.all, search_term)
        when 'field'
          field = params[:field] || 'name'
          result = @search_service.search_by_field(model.all, field, search_term)
        when 'advanced'
          options = params[:options] || {}
          result = @search_service.search_advanced(model.all, options)
        else
          result = @search_service.search(model.all, search_term)
        end
        
        # Apply pagination
        result = @pagination_service.paginate_with_metadata(result, params[:page], params[:per_page])
        
        render json: {
          data: serialize_data(result[:data]),
          pagination: result[:pagination],
          meta: {
            search_term: search_term,
            search_type: search_type,
            total_results: result[:pagination][:total_count],
            search_backend: @search_service.backend_info[:type]
          }
        }
      end

      def search_suggestions
        search_term = params[:q]
        
        if search_term.blank?
          render json: { suggestions: [] }
          return
        end
        
        suggestions = @search_service.search_suggestions(search_term)
        render json: { suggestions: suggestions }
      end
      <% end %>

      # =============================================================================
      # BULK OPERATIONS
      # =============================================================================

      <% if compile_services.any? { |s| s[:name] == 'authorization' } %>
      def bulk_operations
        operation = params[:operation]
        record_ids = params[:record_ids]
        model = get_model_from_params
        
        case operation
        when 'delete'
          perform_bulk_delete(model, record_ids)
        when 'update'
          perform_bulk_update(model, record_ids)
        when 'create'
          perform_bulk_create(model)
        else
          render json: { errors: ['Invalid operation'] }, status: :bad_request
        end
      end
      <% end %>

      # =============================================================================
      # EXPORT/IMPORT ENDPOINTS
      # =============================================================================

      <% if compile_services.any? { |s| s[:name] == 'file_storage' } %>
      def export
        model = get_model_from_params
        format = params[:format] || 'json'
        
        result = @unified_service.execute_query(model, {
          user: current_user,
          per_page: 10000 # Large export
        })
        
        case format
        when 'json'
          render json: { data: serialize_data(result) }
        when 'csv'
          send_data export_to_csv(result), filename: "#{model.name.downcase}_export.csv"
        when 'xlsx'
          send_data export_to_xlsx(result), filename: "#{model.name.downcase}_export.xlsx"
        else
          render json: { errors: ['Unsupported format'] }, status: :bad_request
        end
      end

      def import
        file = params[:file]
        model = get_model_from_params
        
        if file.blank?
          render json: { errors: ['File is required'] }, status: :bad_request
          return
        end
        
        result = import_records(model, file)
        
        if result[:success]
          render json: { 
            message: "Imported #{result[:imported_count]} records",
            imported_count: result[:imported_count],
            errors: result[:errors]
          }
        else
          render json: { errors: result[:errors] }, status: :unprocessable_entity
        end
      end
      <% end %>

      # =============================================================================
      # CACHE MANAGEMENT
      # =============================================================================

      <% if compile_services.any? { |s| s[:name] == 'cache' } %>
      def cache_stats
        stats = @cache_service.cache_stats
        render json: { cache_stats: stats }
      end

      def clear_cache
        pattern = params[:pattern]
        @cache_service.invalidate_cache(pattern)
        render json: { message: t('demo.api.cache_cleared') }
      end
      <% end %>

      # =============================================================================
      # ANALYTICS ENDPOINTS
      # =============================================================================

      <% if compile_services.any? { |s| s[:name] == 'analytics' } %>
      def analytics
        event_name = params[:event]
        properties = params[:properties] || {}
        
        @analytics_service.track_event(event_name, properties, current_user)
        render json: { message: t('demo.api.event_tracked') }
      end

      def analytics_dashboard
        dashboard_data = @analytics_service.get_analytics
        render json: { analytics: dashboard_data }
      end
      <% end %>

      # =============================================================================
      # NOTIFICATION ENDPOINTS
      # =============================================================================

      <% if compile_services.any? { |s| s[:name] == 'notifications' } %>
      def notifications
        user_notifications = @notification_service.get_notifications(current_user, notification_params)
        render json: { notifications: user_notifications }
      end

      def send_notification
        notification_type = params[:type]
        data = params[:data] || {}
        user_id = params[:user_id]
        
        user = user_id ? User.find(user_id) : current_user
        @notification_service.send_notification(user, notification_type, data)
        
        render json: { message: t('demo.api.notification_sent') }
      end

      def mark_notification_read
        notification_id = params[:notification_id]
        @notification_service.mark_read(current_user, notification_id)
        render json: { message: t('demo.api.notification_marked_read') }
      end
      <% end %>

      # =============================================================================
      # FILE UPLOAD ENDPOINTS
      # =============================================================================

      <% if compile_services.any? { |s| s[:name] == 'file_storage' } %>
      def upload_file
        file = params[:file]
        options = params[:options] || {}
        
        if file.blank?
          render json: { errors: [t('demo.api.file_required')] }, status: :bad_request
          return
        end
        
        result = @file_storage_service.upload_file(file, options)
        
        if result
          render json: { 
            file_url: result[:url],
            file_id: result[:id],
            message: t('demo.api.file_uploaded')
          }
        else
          render json: { errors: [t('demo.api.file_upload_failed')] }, status: :unprocessable_entity
        end
      end

      def download_file
        file_id = params[:file_id]
        result = @file_storage_service.download_file(file_id)
        
        if result
          send_data result[:data], filename: result[:filename]
        else
          render json: { errors: [t('demo.api.file_not_found')] }, status: :not_found
        end
      end
      <% end %>

      # =============================================================================
      # PRIVATE METHODS
      # =============================================================================

      private

      def get_model_from_params
        model_name = params[:model] || controller_name.classify
        model_name.constantize
      rescue NameError
        render json: { errors: [t('demo.api.invalid_model')] }, status: :bad_request
        nil
      end

      def find_record
        model = get_model_from_params
        model.find(params[:id])
      end

      def create_params
        params.require(:data).permit!
      end

      def update_params
        params.require(:data).permit!
      end

      def query_params
        params.permit(:search, :page, :per_page, :sort_by, :sort_order, filters: {})
      end

      def notification_params
        params.permit(:page, :per_page, :read, :type)
      end

      def serialize_data(data)
        if data.respond_to?(:each)
          data.map { |item| serialize_item(item) }
        else
          serialize_item(data)
        end
      end

      def serialize_item(item)
        item.as_json
      end

      def pagination_metadata(result)
        return {} unless result.respond_to?(:current_page)
        
        {
          current_page: result.current_page,
          total_pages: result.total_pages,
          total_count: result.total_count,
          per_page: result.limit_value
        }
      end

      <% if compile_services.any? { |s| s[:name] == 'authorization' } %>
      def perform_bulk_delete(model, record_ids)
        records = model.where(id: record_ids)
        deleted_count = 0
        
        records.each do |record|
          result = @unified_service.delete_record(record, current_user)
          deleted_count += 1 if result[:success]
        end
        
        render json: { 
          message: t('demo.api.records_deleted', count: deleted_count),
          deleted_count: deleted_count
        }
      end

      def perform_bulk_update(model, record_ids)
        update_data = params[:update_data] || {}
        updated_count = 0
        
        model.where(id: record_ids).each do |record|
          result = @unified_service.update_record(record, update_data, current_user)
          updated_count += 1 if result[:success]
        end
        
        render json: { 
          message: t('demo.api.records_updated', count: updated_count),
          updated_count: updated_count
        }
      end

      def perform_bulk_create(model)
        records_data = params[:records] || []
        created_count = 0
        errors = []
        
        records_data.each do |record_data|
          result = @unified_service.create_record(model, record_data, current_user)
          if result[:success]
            created_count += 1
          else
            errors << result[:errors]
          end
        end
        
        render json: { 
          message: t('demo.api.records_created', count: created_count),
          created_count: created_count,
          errors: errors
        }
      end
      <% end %>

      <% if compile_services.any? { |s| s[:name] == 'file_storage' } %>
      def export_to_csv(data)
        CSV.generate do |csv|
          # Add headers and data
        end
      end

      def export_to_xlsx(data)
        # XLSX export logic
      end

      def import_records(model, file)
        # Import logic
        { success: true, imported_count: 0, errors: [] }
      end
      <% end %>
    end
  end
end 