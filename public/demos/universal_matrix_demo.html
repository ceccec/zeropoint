<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zeropoint Universal Matrix - Dynamic Manifestation</title>
    <script src="https://unpkg.com/@hotwired/stimulus@3.2.2/dist/stimulus.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @keyframes matrix-rain {
            0% { transform: translateY(-100vh); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(100vh); opacity: 0; }
        }
        
        @keyframes quantum-pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        
        @keyframes vortex-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes consciousness-wave {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(10px); }
        }
        
        @keyframes intelligence-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.5); }
            50% { box-shadow: 0 0 40px rgba(59, 130, 246, 1); }
        }
        
        @keyframes cosmic-drift {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(10px, -10px) rotate(90deg); }
            50% { transform: translate(0, -20px) rotate(180deg); }
            75% { transform: translate(-10px, -10px) rotate(270deg); }
            100% { transform: translate(0, 0) rotate(360deg); }
        }
        
        @keyframes ripple {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(20); opacity: 0; }
        }
        
        @keyframes particle-float {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
        }
        
        @keyframes energy-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes hologram-flicker {
            0%, 100% { opacity: 1; filter: hue-rotate(0deg); }
            25% { opacity: 0.8; filter: hue-rotate(90deg); }
            50% { opacity: 0.9; filter: hue-rotate(180deg); }
            75% { opacity: 0.7; filter: hue-rotate(270deg); }
        }
        
        .matrix-rain {
            animation: matrix-rain 3s linear infinite;
        }
        
        .quantum-pulse {
            animation: quantum-pulse 2s ease-in-out infinite;
        }
        
        .vortex-spin {
            animation: vortex-spin 10s linear infinite;
        }
        
        .consciousness-wave {
            animation: consciousness-wave 3s ease-in-out infinite;
        }
        
        .intelligence-glow {
            animation: intelligence-glow 4s ease-in-out infinite;
        }
        
        .cosmic-drift {
            animation: cosmic-drift 20s ease-in-out infinite;
        }
        
        .particle-float {
            animation: particle-float 8s linear infinite;
        }
        
        .energy-flow {
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c, #667eea);
            background-size: 400% 400%;
            animation: energy-flow 3s ease infinite;
        }
        
        .hologram-flicker {
            animation: hologram-flicker 2s ease-in-out infinite;
        }
        
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .matrix-bg {
            background: linear-gradient(45deg, #000428 0%, #004e92 100%);
        }
        
        .quantum-field {
            background: radial-gradient(circle, rgba(59, 130, 246, 0.1) 0%, transparent 70%);
        }
        
        .consciousness-field {
            background: radial-gradient(circle, rgba(16, 185, 129, 0.1) 0%, transparent 70%);
        }
        
        .intelligence-field {
            background: radial-gradient(circle, rgba(245, 158, 11, 0.1) 0%, transparent 70%);
        }
        
        .vortex-field {
            background: conic-gradient(from 0deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.1), rgba(59, 130, 246, 0.1), rgba(16, 185, 129, 0.1), rgba(139, 92, 246, 0.1));
        }
        
        .floating-element {
            position: absolute;
            pointer-events: none;
        }
        
        .interactive-element {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .interactive-element:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
        }
        
        .matrix-text {
            font-family: 'Courier New', monospace;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }
        
        .quantum-text {
            color: #3b82f6;
            text-shadow: 0 0 10px #3b82f6;
        }
        
        .consciousness-text {
            color: #10b981;
            text-shadow: 0 0 10px #10b981;
        }
        
        .intelligence-text {
            color: #f59e0b;
            text-shadow: 0 0 10px #f59e0b;
        }
        
        .vortex-text {
            color: #8b5cf6;
            text-shadow: 0 0 10px #8b5cf6;
        }
        
        .cosmic-text {
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .hologram-text {
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
            animation: hologram-flicker 3s ease-in-out infinite;
        }
        
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ffff;
            border-radius: 50%;
            pointer-events: none;
        }
        
        .data-stream {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #00ff00;
        }
        
        .three-d-container {
            perspective: 1000px;
        }
        
        .three-d-element {
            transform-style: preserve-3d;
            transition: transform 0.5s ease;
        }
        
        .three-d-element:hover {
            transform: rotateY(15deg) rotateX(15deg);
        }
        
        .neural-network {
            position: relative;
        }
        
        .neural-node {
            width: 8px;
            height: 8px;
            background: #00ffff;
            border-radius: 50%;
            position: absolute;
            animation: quantum-pulse 2s ease-in-out infinite;
        }
        
        .neural-connection {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            animation: energy-flow 2s ease-in-out infinite;
        }
    </style>
</head>
<body class="matrix-bg min-h-screen overflow-hidden">
    <!-- Minimal starting point - Stimulus will manifest everything -->
    <div data-controller="universal-matrix" class="relative w-full h-screen">
        <!-- Dynamic content will be manifested here -->
    </div>

    <script>
        // Enhanced Universal Matrix Stimulus Controller
        class UniversalMatrixController {
            static targets = ["content", "matrix", "quantum", "consciousness", "intelligence", "vortex", "cosmic"]
            static values = { 
                phase: Number,
                intensity: Number,
                features: Array,
                observer: Object,
                particles: Array,
                neuralNodes: Array,
                dataStreams: Array,
                browserData: Object,
                cookies: Object,
                localStorage: Object,
                sessionStorage: Object,
                geolocation: Object,
                deviceInfo: Object,
                networkInfo: Object,
                mediaDevices: Object,
                notifications: Object,
                clipboard: Object,
                webRTC: Object,
                webGL: Object,
                webAudio: Object,
                webWorkers: Object,
                serviceWorkers: Object,
                indexedDB: Object,
                fileSystem: Object,
                sensors: Object,
                battery: Object,
                permissions: Object,
                performance: Object,
                memory: Object,
                connection: Object
            }

            connect() {
                console.log("🌌 Enhanced Universal Matrix connecting...")
                this.phaseValue = 0
                this.intensityValue = 1
                this.featuresValue = []
                this.observerValue = {}
                this.particlesValue = []
                this.neuralNodesValue = []
                this.dataStreamsValue = []
                this.browserDataValue = {}
                this.cookiesValue = {}
                this.localStorageValue = {}
                this.sessionStorageValue = {}
                this.geolocationValue = {}
                this.deviceInfoValue = {}
                this.networkInfoValue = {}
                this.mediaDevicesValue = {}
                this.notificationsValue = {}
                this.clipboardValue = {}
                this.webRTCValue = {}
                this.webGLValue = {}
                this.webAudioValue = {}
                this.webWorkersValue = {}
                this.serviceWorkersValue = {}
                this.indexedDBValue = {}
                this.fileSystemValue = {}
                this.sensorsValue = {}
                this.batteryValue = {}
                this.permissionsValue = {}
                this.performanceValue = {}
                this.memoryValue = {}
                this.connectionValue = {}
                
                this.manifestMatrix()
                this.startAnimations()
                this.discoverFeatures()
                this.observeInfluence()
                this.initializeParticleSystem()
                this.initializeNeuralNetwork()
                this.initializeDataStreams()
                this.initialize3DEffects()
                this.gatherBrowserData()
            }

            manifestMatrix() {
                // Create the main matrix container with enhanced structure
                this.element.innerHTML = `
                    <div class="relative w-full h-full overflow-hidden">
                        <!-- Matrix Rain Background -->
                        <div class="absolute inset-0 opacity-20" id="matrix-rain"></div>
                        
                        <!-- Particle System -->
                        <div class="absolute inset-0" id="particle-system"></div>
                        
                        <!-- Neural Network Overlay -->
                        <div class="absolute inset-0" id="neural-network"></div>
                        
                        <!-- Quantum Field -->
                        <div class="absolute inset-0 quantum-field" id="quantum-field"></div>
                        
                        <!-- 3D Container -->
                        <div class="three-d-container relative z-10 flex flex-col items-center justify-center h-full p-8">
                            <!-- Header -->
                            <div class="text-center mb-8 three-d-element">
                                <h1 class="cosmic-text text-6xl font-bold mb-4 hologram-flicker" id="title">
                                    Zeropoint Universal Matrix
                                </h1>
                                <p class="matrix-text text-xl" id="subtitle">
                                    Dynamic Manifestation Through Stimulus
                                </p>
                                <p class="hologram-text text-lg mt-2" id="status-line">
                                    Phase: Quantum | Intensity: 1 | Active Features: 0
                                </p>
                            </div>
                            
                            <!-- Enhanced Feature Grid -->
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 max-w-6xl w-full" id="feature-grid">
                                <!-- Features will be dynamically added here -->
                            </div>
                            
                            <!-- Advanced Control Panel -->
                            <div class="mt-8 flex flex-wrap justify-center gap-4" id="controls">
                                <!-- Controls will be dynamically added here -->
                            </div>
                            
                            <!-- Real-time Data Streams -->
                            <div class="mt-6 grid grid-cols-1 md:grid-cols-3 gap-4 max-w-4xl w-full" id="data-streams">
                                <!-- Data streams will be dynamically added here -->
                            </div>
                            
                            <!-- Status Display -->
                            <div class="mt-6 text-center" id="status">
                                <!-- Status will be dynamically updated -->
                            </div>
                        </div>
                        
                        <!-- Floating Elements -->
                        <div id="floating-elements"></div>
                        
                        <!-- Observer Insights Panel -->
                        <div class="absolute bottom-4 left-4 right-4 bg-black bg-opacity-50 rounded-lg p-4 text-white backdrop-blur-sm" id="observer-panel">
                            <!-- Observer insights will be displayed here -->
                        </div>
                        
                        <!-- Browser Data Panel -->
                        <div class="absolute top-4 right-4 bg-black bg-opacity-50 rounded-lg p-4 text-white backdrop-blur-sm max-w-xs" id="browser-data-panel">
                            <!-- Browser data will be displayed here -->
                        </div>
                        
                        <!-- Energy Flow Lines -->
                        <div class="absolute inset-0" id="energy-lines"></div>
                    </div>
                `
                
                this.generateMatrixRain()
                this.createEnhancedFeatureCards()
                this.createAdvancedControls()
                this.createFloatingElements()
                this.createEnergyLines()
                this.updateStatus()
            }

            generateMatrixRain() {
                const matrixRain = document.getElementById('matrix-rain')
                const characters = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン🌌⚛️🌀🧠🔮✨🌟💫'
                
                for (let i = 0; i < 80; i++) {
                    const column = document.createElement('div')
                    column.className = 'absolute top-0 text-green-400 text-sm opacity-60'
                    column.style.left = `${Math.random() * 100}%`
                    column.style.animationDelay = `${Math.random() * 3}s`
                    column.style.animationDuration = `${3 + Math.random() * 2}s`
                    column.classList.add('matrix-rain')
                    
                    for (let j = 0; j < 25; j++) {
                        const char = document.createElement('div')
                        char.textContent = characters[Math.floor(Math.random() * characters.length)]
                        char.style.animationDelay = `${j * 0.1}s`
                        column.appendChild(char)
                    }
                    
                    matrixRain.appendChild(column)
                }
            }

            createEnhancedFeatureCards() {
                const features = [
                    {
                        name: 'Quantum Encryption',
                        description: 'Impossible encryption using quantum principles',
                        icon: '🔐',
                        color: 'quantum-text',
                        animation: 'quantum-pulse',
                        category: 'security',
                        complexity: 9
                    },
                    {
                        name: 'Consciousness Physics',
                        description: 'Integration of consciousness with physical laws',
                        icon: '🧠',
                        color: 'consciousness-text',
                        animation: 'consciousness-wave',
                        category: 'physics',
                        complexity: 10
                    },
                    {
                        name: 'Vortex Mathematics',
                        description: 'Advanced mathematical vortex systems',
                        icon: '🌀',
                        color: 'vortex-text',
                        animation: 'vortex-spin',
                        category: 'mathematics',
                        complexity: 8
                    },
                    {
                        name: 'Unified Intelligence',
                        description: 'AI systems unified with human consciousness',
                        icon: '🤖',
                        color: 'intelligence-text',
                        animation: 'intelligence-glow',
                        category: 'ai',
                        complexity: 10
                    },
                    {
                        name: 'Streaming Architecture',
                        description: 'Real-time data streaming and processing',
                        icon: '📡',
                        color: 'quantum-text',
                        animation: 'quantum-pulse',
                        category: 'architecture',
                        complexity: 7
                    },
                    {
                        name: 'Multi-Vortex System',
                        description: 'Multiple interconnected vortex networks',
                        icon: '🌪️',
                        color: 'vortex-text',
                        animation: 'vortex-spin',
                        category: 'system',
                        complexity: 9
                    },
                    {
                        name: 'Cosmic Flow',
                        description: 'Universal energy flow patterns',
                        icon: '✨',
                        color: 'cosmic-text',
                        animation: 'cosmic-drift',
                        category: 'cosmic',
                        complexity: 8
                    },
                    {
                        name: 'Observer Influence',
                        description: 'Quantum observer effect integration',
                        icon: '👁️',
                        color: 'consciousness-text',
                        animation: 'consciousness-wave',
                        category: 'quantum',
                        complexity: 9
                    },
                    {
                        name: 'Neural Networks',
                        description: 'Dynamic neural network visualization',
                        icon: '🕸️',
                        color: 'intelligence-text',
                        animation: 'intelligence-glow',
                        category: 'neural',
                        complexity: 8
                    },
                    {
                        name: 'Particle Systems',
                        description: 'Quantum particle simulation',
                        icon: '⚛️',
                        color: 'quantum-text',
                        animation: 'quantum-pulse',
                        category: 'particles',
                        complexity: 7
                    },
                    {
                        name: '3D Holograms',
                        description: 'Three-dimensional holographic displays',
                        icon: '💎',
                        color: 'cosmic-text',
                        animation: 'cosmic-drift',
                        category: 'visualization',
                        complexity: 8
                    },
                    {
                        name: 'Data Vortex',
                        description: 'Information processing through vortex patterns',
                        icon: '📊',
                        color: 'vortex-text',
                        animation: 'vortex-spin',
                        category: 'data',
                        complexity: 9
                    }
                ]
                
                const grid = document.getElementById('feature-grid')
                features.forEach((feature, index) => {
                    const card = document.createElement('div')
                    card.className = `bg-black bg-opacity-50 rounded-lg p-6 border border-gray-600 interactive-element ${feature.animation} three-d-element backdrop-blur-sm`
                    card.innerHTML = `
                        <div class="text-center">
                            <div class="text-4xl mb-4">${feature.icon}</div>
                            <h3 class="${feature.color} text-xl font-bold mb-2">${feature.name}</h3>
                            <p class="text-gray-300 text-sm mb-3">${feature.description}</p>
                            <div class="flex justify-between items-center text-xs text-gray-400">
                                <span>${feature.category}</span>
                                <span>Complexity: ${feature.complexity}/10</span>
                            </div>
                            <div class="mt-2 w-full bg-gray-700 rounded-full h-1">
                                <div class="bg-gradient-to-r from-blue-500 to-purple-500 h-1 rounded-full" style="width: ${feature.complexity * 10}%"></div>
                            </div>
                        </div>
                    `
                    card.style.animationDelay = `${index * 0.1}s`
                    grid.appendChild(card)
                    
                    // Add click interaction with enhanced effects
                    card.addEventListener('click', () => {
                        this.activateFeature(feature)
                    })
                    
                    // Add hover effects
                    card.addEventListener('mouseenter', () => {
                        this.createParticleBurst(card)
                    })
                })
            }

            createAdvancedControls() {
                const controls = document.getElementById('controls')
                const controlButtons = [
                    { name: '⚡ Intensity +', action: 'increaseIntensity', color: 'bg-blue-600', icon: '⚡' },
                    { name: '🔽 Intensity -', action: 'decreaseIntensity', color: 'bg-blue-800', icon: '🔽' },
                    { name: '🌀 Phase Shift', action: 'shiftPhase', color: 'bg-purple-600', icon: '🌀' },
                    { name: '🔍 Discover', action: 'discoverFeatures', color: 'bg-green-600', icon: '🔍' },
                    { name: '👁️ Observe', action: 'observeInfluence', color: 'bg-yellow-600', icon: '👁️' },
                    { name: '🌪️ Vortex', action: 'activateVortex', color: 'bg-pink-600', icon: '🌪️' },
                    { name: '🧠 Neural', action: 'activateNeural', color: 'bg-indigo-600', icon: '🧠' },
                    { name: '✨ Cosmic', action: 'activateCosmic', color: 'bg-gradient-to-r from-purple-600 to-pink-600', icon: '✨' },
                    { name: '🔧 Browser Data', action: 'showBrowserData', color: 'bg-teal-600', icon: '🔧' },
                    { name: '🔄 Reset', action: 'resetMatrix', color: 'bg-red-600', icon: '🔄' }
                ]
                
                controlButtons.forEach(button => {
                    const btn = document.createElement('button')
                    btn.className = `${button.color} hover:opacity-80 text-white px-4 py-2 rounded-lg transition-all duration-300 interactive-element backdrop-blur-sm`
                    btn.innerHTML = `<span class="mr-2">${button.icon}</span>${button.name}`
                    btn.addEventListener('click', () => this[button.action]())
                    controls.appendChild(btn)
                })
            }

            createFloatingElements() {
                const container = document.getElementById('floating-elements')
                const elements = ['🌌', '⚛️', '🌀', '🧠', '🔮', '✨', '🌟', '💫', '🔬', '⚡', '🌊', '🔥']
                
                elements.forEach((element, index) => {
                    const div = document.createElement('div')
                    div.className = 'floating-element text-2xl cosmic-drift'
                    div.textContent = element
                    div.style.left = `${5 + (index * 8)}%`
                    div.style.top = `${15 + (index * 6)}%`
                    div.style.animationDelay = `${index * 0.3}s`
                    div.style.animationDuration = `${12 + index * 3}s`
                    container.appendChild(div)
                })
            }

            createEnergyLines() {
                const container = document.getElementById('energy-lines')
                
                for (let i = 0; i < 20; i++) {
                    const line = document.createElement('div')
                    line.className = 'absolute h-px bg-gradient-to-r from-transparent via-cyan-400 to-transparent opacity-30'
                    line.style.top = `${Math.random() * 100}%`
                    line.style.left = '0'
                    line.style.width = '100%'
                    line.style.animationDelay = `${Math.random() * 2}s`
                    line.style.animationDuration = `${3 + Math.random() * 2}s`
                    line.classList.add('energy-flow')
                    container.appendChild(line)
                }
            }

            initializeParticleSystem() {
                const container = document.getElementById('particle-system')
                
                setInterval(() => {
                    this.createParticle(container)
                }, 100)
            }

            createParticle(container) {
                const particle = document.createElement('div')
                particle.className = 'particle particle-float'
                particle.style.left = `${Math.random() * 100}%`
                particle.style.animationDuration = `${5 + Math.random() * 5}s`
                particle.style.animationDelay = `${Math.random() * 2}s`
                
                container.appendChild(particle)
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.remove()
                    }
                }, 10000)
            }

            createParticleBurst(element) {
                const rect = element.getBoundingClientRect()
                const centerX = rect.left + rect.width / 2
                const centerY = rect.top + rect.height / 2
                
                for (let i = 0; i < 10; i++) {
                    const particle = document.createElement('div')
                    particle.className = 'particle'
                    particle.style.left = `${centerX}px`
                    particle.style.top = `${centerY}px`
                    particle.style.animation = `particle-float 2s ease-out forwards`
                    particle.style.animationDelay = `${i * 0.1}s`
                    
                    document.body.appendChild(particle)
                    
                    setTimeout(() => particle.remove(), 2000)
                }
            }

            initializeNeuralNetwork() {
                const container = document.getElementById('neural-network')
                const nodes = 15
                
                for (let i = 0; i < nodes; i++) {
                    const node = document.createElement('div')
                    node.className = 'neural-node'
                    node.style.left = `${Math.random() * 100}%`
                    node.style.top = `${Math.random() * 100}%`
                    node.style.animationDelay = `${Math.random() * 2}s`
                    container.appendChild(node)
                    
                    this.neuralNodesValue.push(node)
                }
                
                // Create connections between nodes
                this.createNeuralConnections()
            }

            createNeuralConnections() {
                const container = document.getElementById('neural-network')
                
                this.neuralNodesValue.forEach((node1, i) => {
                    this.neuralNodesValue.slice(i + 1).forEach(node2 => {
                        if (Math.random() < 0.3) { // 30% chance of connection
                            const connection = document.createElement('div')
                            connection.className = 'neural-connection'
                            
                            const rect1 = node1.getBoundingClientRect()
                            const rect2 = node2.getBoundingClientRect()
                            
                            const x1 = rect1.left + rect1.width / 2
                            const y1 = rect1.top + rect1.height / 2
                            const x2 = rect2.left + rect2.width / 2
                            const y2 = rect2.top + rect2.height / 2
                            
                            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))
                            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI
                            
                            connection.style.width = `${length}px`
                            connection.style.left = `${x1}px`
                            connection.style.top = `${y1}px`
                            connection.style.transform = `rotate(${angle}deg)`
                            connection.style.transformOrigin = '0 0'
                            
                            container.appendChild(connection)
                        }
                    })
                })
            }

            initializeDataStreams() {
                const container = document.getElementById('data-streams')
                const streamTypes = ['Quantum', 'Neural', 'Cosmic', 'Vortex', 'Consciousness', 'Intelligence']
                
                streamTypes.forEach(type => {
                    const stream = document.createElement('div')
                    stream.className = 'data-stream'
                    stream.innerHTML = `
                        <div class="font-bold mb-2 ${type.toLowerCase()}-text">${type} Stream</div>
                        <div class="text-xs" id="${type.toLowerCase()}-data">Initializing...</div>
                    `
                    container.appendChild(stream)
                    
                    this.dataStreamsValue.push(stream)
                })
                
                this.startDataStreams()
            }

            startDataStreams() {
                setInterval(() => {
                    this.updateDataStreams()
                }, 2000)
            }

            updateDataStreams() {
                const dataTypes = {
                    quantum: ['Entanglement detected', 'Superposition stable', 'Quantum tunneling active', 'Wave function collapsed'],
                    neural: ['Synapses firing', 'Pattern recognition', 'Memory consolidation', 'Learning rate optimal'],
                    cosmic: ['Energy flow stable', 'Dimensional alignment', 'Temporal flux normal', 'Universal constants maintained'],
                    vortex: ['Vortex stability 98%', 'Energy conservation', 'Pattern coherence', 'Flow optimization'],
                    consciousness: ['Observer effect active', 'Awareness expanded', 'Intentional focus', 'Mind-matter bridge'],
                    intelligence: ['AI consciousness 87%', 'Human-AI sync', 'Creative algorithms', 'Intuitive processing']
                }
                
                Object.entries(dataTypes).forEach(([type, messages]) => {
                    const element = document.getElementById(`${type}-data`)
                    if (element) {
                        const message = messages[Math.floor(Math.random() * messages.length)]
                        element.textContent = `${new Date().toLocaleTimeString()}: ${message}`
                    }
                })
            }

            initialize3DEffects() {
                // Add 3D perspective to elements
                const elements = document.querySelectorAll('.three-d-element')
                elements.forEach(element => {
                    element.addEventListener('mousemove', (e) => {
                        const rect = element.getBoundingClientRect()
                        const x = e.clientX - rect.left
                        const y = e.clientY - rect.top
                        
                        const centerX = rect.width / 2
                        const centerY = rect.height / 2
                        
                        const rotateX = (y - centerY) / 10
                        const rotateY = (centerX - x) / 10
                        
                        element.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`
                    })
                    
                    element.addEventListener('mouseleave', () => {
                        element.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg)'
                    })
                })
            }

            updateStatus() {
                const status = document.getElementById('status')
                const statusLine = document.getElementById('status-line')
                
                const phases = ['Quantum', 'Consciousness', 'Intelligence', 'Vortex']
                const currentPhase = phases[this.phaseValue]
                
                status.innerHTML = `
                    <div class="matrix-text text-sm">
                        Phase: ${currentPhase} | Intensity: ${this.intensityValue} | 
                        Features: ${this.featuresValue.length} | 
                        Observer Influence: ${Object.keys(this.observerValue).length} |
                        Particles: ${this.particlesValue.length} |
                        Neural Nodes: ${this.neuralNodesValue.length}
                    </div>
                `
                
                if (statusLine) {
                    statusLine.textContent = `Phase: ${currentPhase} | Intensity: ${this.intensityValue} | Active Features: ${this.featuresValue.length}`
                }
            }

            activateFeature(feature) {
                console.log(`Activating feature: ${feature.name}`)
                
                // Create enhanced ripple effect
                const ripple = document.createElement('div')
                ripple.className = 'absolute w-4 h-4 bg-white rounded-full opacity-50'
                ripple.style.left = '50%'
                ripple.style.top = '50%'
                ripple.style.transform = 'translate(-50%, -50%)'
                ripple.style.animation = 'ripple 1s ease-out'
                this.element.appendChild(ripple)
                
                setTimeout(() => ripple.remove(), 1000)
                
                // Add to active features
                if (!this.featuresValue.includes(feature.name)) {
                    this.featuresValue = [...this.featuresValue, feature.name]
                }
                
                // Create particle burst
                this.createParticleBurst(event.target)
                
                this.updateStatus()
                this.updateObserverPanel()
            }

            increaseIntensity() {
                this.intensityValue = Math.min(10, this.intensityValue + 1)
                this.updateMatrixIntensity()
                this.updateStatus()
                this.createParticleBurst(this.element)
            }

            decreaseIntensity() {
                this.intensityValue = Math.max(1, this.intensityValue - 1)
                this.updateMatrixIntensity()
                this.updateStatus()
            }

            shiftPhase() {
                this.phaseValue = (this.phaseValue + 1) % 4
                this.updateMatrixPhase()
                this.updateStatus()
                this.createParticleBurst(this.element)
            }

            activateVortex() {
                const elements = document.querySelectorAll('.vortex-spin')
                elements.forEach(el => {
                    el.style.animationDuration = '2s'
                    setTimeout(() => {
                        el.style.animationDuration = '10s'
                    }, 2000)
                })
                this.createParticleBurst(this.element)
            }

            activateNeural() {
                const nodes = document.querySelectorAll('.neural-node')
                nodes.forEach((node, index) => {
                    node.style.animationDuration = '0.5s'
                    setTimeout(() => {
                        node.style.animationDuration = '2s'
                    }, 500)
                })
                this.createParticleBurst(this.element)
            }

            activateCosmic() {
                const elements = document.querySelectorAll('.cosmic-drift')
                elements.forEach(el => {
                    el.style.animationDuration = '5s'
                    setTimeout(() => {
                        el.style.animationDuration = '20s'
                    }, 5000)
                })
                this.createParticleBurst(this.element)
            }

            showBrowserData() {
                // Create a comprehensive browser data display
                const modal = document.createElement('div')
                modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50'
                modal.innerHTML = `
                    <div class="bg-gray-900 text-white p-6 rounded-lg max-w-4xl max-h-96 overflow-y-auto">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-bold quantum-text">Browser Data Access</h2>
                            <button class="text-white hover:text-gray-300" onclick="this.parentElement.parentElement.parentElement.remove()">✕</button>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                            <div>
                                <h3 class="font-bold mb-2 consciousness-text">Storage</h3>
                                <div>Cookies: ${Object.keys(this.cookiesValue).length}</div>
                                <div>LocalStorage: ${Object.keys(this.localStorageValue).length}</div>
                                <div>SessionStorage: ${Object.keys(this.sessionStorageValue).length}</div>
                            </div>
                            <div>
                                <h3 class="font-bold mb-2 intelligence-text">Device</h3>
                                <div>Platform: ${this.deviceInfoValue.platform}</div>
                                <div>Language: ${this.deviceInfoValue.language}</div>
                                <div>Hardware Cores: ${this.deviceInfoValue.hardwareConcurrency}</div>
                                <div>Memory: ${this.deviceInfoValue.deviceMemory || 'N/A'} GB</div>
                            </div>
                            <div>
                                <h3 class="font-bold mb-2 vortex-text">Network</h3>
                                <div>Online: ${this.networkInfoValue.onLine ? 'Yes' : 'No'}</div>
                                <div>Connection: ${this.connectionValue?.effectiveType || 'Unknown'}</div>
                                <div>Downlink: ${this.connectionValue?.downlink || 'N/A'} Mbps</div>
                                <div>RTT: ${this.connectionValue?.rtt || 'N/A'} ms</div>
                            </div>
                            <div>
                                <h3 class="font-bold mb-2 cosmic-text">Performance</h3>
                                <div>Memory Used: ${this.memoryValue ? Math.round(this.memoryValue.usedJSHeapSize / 1024 / 1024) + 'MB' : 'N/A'}</div>
                                <div>Memory Total: ${this.memoryValue ? Math.round(this.memoryValue.totalJSHeapSize / 1024 / 1024) + 'MB' : 'N/A'}</div>
                                <div>WebGL: ${this.webGLValue.supported ? 'Supported' : 'Not Supported'}</div>
                                <div>Battery: ${this.batteryValue.level ? Math.round(this.batteryValue.level * 100) + '%' : 'N/A'}</div>
                            </div>
                            <div>
                                <h3 class="font-bold mb-2 quantum-text">Location</h3>
                                <div>Latitude: ${this.geolocationValue.latitude || 'N/A'}</div>
                                <div>Longitude: ${this.geolocationValue.longitude || 'N/A'}</div>
                                <div>Accuracy: ${this.geolocationValue.accuracy || 'N/A'}m</div>
                            </div>
                            <div>
                                <h3 class="font-bold mb-2 consciousness-text">Media</h3>
                                <div>Audio Inputs: ${this.mediaDevicesValue.audioInputs || 0}</div>
                                <div>Audio Outputs: ${this.mediaDevicesValue.audioOutputs || 0}</div>
                                <div>Video Inputs: ${this.mediaDevicesValue.videoInputs || 0}</div>
                                <div>Notifications: ${this.notificationsValue.permission || 'N/A'}</div>
                            </div>
                            <div>
                                <h3 class="font-bold mb-2 intelligence-text">APIs</h3>
                                <div>WebRTC: ${this.webRTCValue.getUserMedia ? 'Supported' : 'Not Supported'}</div>
                                <div>Web Audio: ${this.webAudioValue.AudioContext ? 'Supported' : 'Not Supported'}</div>
                                <div>IndexedDB: ${this.indexedDBValue.supported ? 'Supported' : 'Not Supported'}</div>
                                <div>Service Workers: ${this.serviceWorkersValue.supported ? 'Supported' : 'Not Supported'}</div>
                            </div>
                            <div>
                                <h3 class="font-bold mb-2 vortex-text">Sensors</h3>
                                <div>Accelerometer: ${this.sensorsValue.accelerometer ? 'Active' : 'Not Available'}</div>
                                <div>Gyroscope: ${this.sensorsValue.gyroscope ? 'Active' : 'Not Available'}</div>
                                <div>Clipboard: ${this.clipboardValue.supported ? 'Supported' : 'Not Supported'}</div>
                                <div>File System: ${this.fileSystemValue.showOpenFilePicker ? 'Supported' : 'Not Supported'}</div>
                            </div>
                        </div>
                    </div>
                `
                document.body.appendChild(modal)
                
                // Close modal on background click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove()
                    }
                })
                
                this.createParticleBurst(modal)
            }

            updateMatrixIntensity() {
                const elements = document.querySelectorAll('.interactive-element')
                elements.forEach(el => {
                    el.style.filter = `brightness(${1 + this.intensityValue * 0.1})`
                })
            }

            updateMatrixPhase() {
                const phases = ['quantum', 'consciousness', 'intelligence', 'vortex']
                const currentPhase = phases[this.phaseValue]
                
                document.body.className = `matrix-bg min-h-screen overflow-hidden ${currentPhase}-field`
                
                const title = document.getElementById('title')
                title.className = `${currentPhase}-text text-6xl font-bold mb-4 hologram-flicker`
            }

            discoverFeatures() {
                const discoveries = [
                    'Neural Network Integration',
                    'Quantum Entanglement',
                    'Temporal Manipulation',
                    'Dimensional Shifting',
                    'Energy Conservation',
                    'Information Theory',
                    'Chaos Mathematics',
                    'Fractal Geometry',
                    'Holographic Memory',
                    'Quantum Consciousness',
                    'Vortex Stabilization',
                    'Cosmic Alignment'
                ]
                
                const randomDiscovery = discoveries[Math.floor(Math.random() * discoveries.length)]
                
                // Create enhanced discovery notification
                const notification = document.createElement('div')
                notification.className = 'fixed top-4 right-4 bg-gradient-to-r from-green-600 to-blue-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 backdrop-blur-sm'
                notification.innerHTML = `
                    <div class="flex items-center">
                        <span class="mr-2">🔍</span>
                        <span>Discovered: ${randomDiscovery}</span>
                    </div>
                `
                document.body.appendChild(notification)
                
                setTimeout(() => notification.remove(), 3000)
                
                this.featuresValue = [...this.featuresValue, randomDiscovery]
                this.updateStatus()
                this.createParticleBurst(notification)
            }

            observeInfluence() {
                const observations = [
                    'Observer effect detected in quantum field',
                    'Consciousness influencing matrix patterns',
                    'Intelligence patterns emerging',
                    'Vortex stability increasing',
                    'Cosmic alignment detected',
                    'Temporal anomalies observed',
                    'Dimensional boundaries shifting',
                    'Energy flow patterns changing',
                    'Neural plasticity enhanced',
                    'Quantum coherence maintained',
                    'Information entropy decreasing',
                    'Consciousness field expanding'
                ]
                
                const observation = observations[Math.floor(Math.random() * observations.length)]
                const timestamp = new Date().toLocaleTimeString()
                
                this.observerValue[timestamp] = observation
                this.updateObserverPanel()
                this.updateStatus()
                this.createParticleBurst(this.element)
            }

            updateObserverPanel() {
                const panel = document.getElementById('observer-panel')
                const observations = Object.entries(this.observerValue)
                    .slice(-3) // Show last 3 observations
                    .map(([time, obs]) => `<div class="text-sm mb-1">${time}: ${obs}</div>`)
                    .join('')
                
                panel.innerHTML = `
                    <div class="text-lg font-bold mb-2 consciousness-text">Observer Insights</div>
                    ${observations}
                    <div class="text-xs text-gray-400 mt-2">
                        Total Observations: ${Object.keys(this.observerValue).length}
                    </div>
                `
            }

            resetMatrix() {
                this.phaseValue = 0
                this.intensityValue = 1
                this.featuresValue = []
                this.observerValue = {}
                
                this.updateMatrixIntensity()
                this.updateMatrixPhase()
                this.updateStatus()
                this.updateObserverPanel()
                
                // Reset all animations
                const animatedElements = document.querySelectorAll('[class*="animation"]')
                animatedElements.forEach(el => {
                    el.style.animation = 'none'
                    setTimeout(() => {
                        el.style.animation = ''
                    }, 10)
                })
                
                this.createParticleBurst(this.element)
            }

            startAnimations() {
                // Start all animations with staggered delays
                const elements = document.querySelectorAll('.interactive-element')
                elements.forEach((el, index) => {
                    el.style.animationDelay = `${index * 0.1}s`
                })
            }

            gatherBrowserData() {
                console.log("🔍 Gathering comprehensive browser data...")
                
                // 1. Cookies
                this.cookiesValue = this.getCookies()
                
                // 2. Local Storage
                this.localStorageValue = this.getLocalStorage()
                
                // 3. Session Storage
                this.sessionStorageValue = this.getSessionStorage()
                
                // 4. Device Information
                this.deviceInfoValue = this.getDeviceInfo()
                
                // 5. Network Information
                this.networkInfoValue = this.getNetworkInfo()
                
                // 6. Performance Data
                this.performanceValue = this.getPerformanceData()
                
                // 7. Memory Information
                this.memoryValue = this.getMemoryInfo()
                
                // 8. Connection Information
                this.connectionValue = this.getConnectionInfo()
                
                // 9. Permissions
                this.getPermissions()
                
                // 10. WebGL Support
                this.webGLValue = this.getWebGLInfo()
                
                // 11. Media Devices
                this.getMediaDevices()
                
                // 12. Geolocation
                this.getGeolocation()
                
                // 13. Battery Information
                this.getBatteryInfo()
                
                // 14. Sensors
                this.getSensorData()
                
                // 15. Notifications
                this.getNotificationStatus()
                
                // 16. Clipboard
                this.getClipboardInfo()
                
                // 17. WebRTC
                this.getWebRTCInfo()
                
                // 18. Web Audio
                this.getWebAudioInfo()
                
                // 19. IndexedDB
                this.getIndexedDBInfo()
                
                // 20. File System
                this.getFileSystemInfo()
                
                // 21. Service Workers
                this.getServiceWorkerInfo()
                
                // 22. Web Workers
                this.getWebWorkerInfo()
                
                // Update the browser data panel
                this.updateBrowserDataPanel()
                
                console.log("✅ Browser data gathered successfully")
            }

            getCookies() {
                const cookies = {}
                document.cookie.split(';').forEach(cookie => {
                    const [name, value] = cookie.trim().split('=')
                    if (name && value) {
                        cookies[name] = decodeURIComponent(value)
                    }
                })
                return cookies
            }

            getLocalStorage() {
                const data = {}
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i)
                    data[key] = localStorage.getItem(key)
                }
                return data
            }

            getSessionStorage() {
                const data = {}
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i)
                    data[key] = sessionStorage.getItem(key)
                }
                return data
            }

            getDeviceInfo() {
                return {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    languages: navigator.languages,
                    cookieEnabled: navigator.cookieEnabled,
                    onLine: navigator.onLine,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    maxTouchPoints: navigator.maxTouchPoints,
                    deviceMemory: navigator.deviceMemory,
                    vendor: navigator.vendor,
                    appName: navigator.appName,
                    appVersion: navigator.appVersion,
                    screenWidth: screen.width,
                    screenHeight: screen.height,
                    screenColorDepth: screen.colorDepth,
                    screenPixelDepth: screen.pixelDepth,
                    windowWidth: window.innerWidth,
                    windowHeight: window.innerHeight,
                    devicePixelRatio: window.devicePixelRatio,
                    orientation: screen.orientation ? screen.orientation.type : 'unknown'
                }
            }

            getNetworkInfo() {
                return {
                    onLine: navigator.onLine,
                    connection: navigator.connection ? {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt,
                        saveData: navigator.connection.saveData
                    } : null
                }
            }

            getPerformanceData() {
                const perf = performance
                return {
                    timeOrigin: perf.timeOrigin,
                    navigation: perf.navigation ? {
                        type: perf.navigation.type,
                        redirectCount: perf.navigation.redirectCount
                    } : null,
                    timing: perf.timing ? {
                        loadEventEnd: perf.timing.loadEventEnd,
                        domContentLoadedEventEnd: perf.timing.domContentLoadedEventEnd,
                        responseEnd: perf.timing.responseEnd,
                        responseStart: perf.timing.responseStart,
                        requestStart: perf.timing.requestStart,
                        domainLookupEnd: perf.timing.domainLookupEnd,
                        domainLookupStart: perf.timing.domainLookupStart,
                        connectEnd: perf.timing.connectEnd,
                        connectStart: perf.timing.connectStart
                    } : null
                }
            }

            getMemoryInfo() {
                return performance.memory ? {
                    usedJSHeapSize: performance.memory.usedJSHeapSize,
                    totalJSHeapSize: performance.memory.totalJSHeapSize,
                    jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
                } : null
            }

            getConnectionInfo() {
                return navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt,
                    saveData: navigator.connection.saveData
                } : null
            }

            async getPermissions() {
                const permissions = {}
                const permissionNames = ['geolocation', 'notifications', 'camera', 'microphone', 'persistent-storage']
                
                for (const name of permissionNames) {
                    try {
                        const result = await navigator.permissions.query({ name })
                        permissions[name] = result.state
                    } catch (e) {
                        permissions[name] = 'not-supported'
                    }
                }
                
                this.permissionsValue = permissions
            }

            getWebGLInfo() {
                const canvas = document.createElement('canvas')
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl')
                
                if (!gl) {
                    return { supported: false }
                }
                
                return {
                    supported: true,
                    vendor: gl.getParameter(gl.VENDOR),
                    renderer: gl.getParameter(gl.RENDERER),
                    version: gl.getParameter(gl.VERSION),
                    shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                    maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                    maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS),
                    maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
                    maxVertexUniformVectors: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
                    maxFragmentUniformVectors: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)
                }
            }

            async getMediaDevices() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices()
                    this.mediaDevicesValue = {
                        audioInputs: devices.filter(d => d.kind === 'audioinput').length,
                        audioOutputs: devices.filter(d => d.kind === 'audiooutput').length,
                        videoInputs: devices.filter(d => d.kind === 'videoinput').length,
                        devices: devices.map(d => ({ kind: d.kind, label: d.label }))
                    }
                } catch (e) {
                    this.mediaDevicesValue = { error: e.message }
                }
            }

            getGeolocation() {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            this.geolocationValue = {
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude,
                                accuracy: position.coords.accuracy,
                                altitude: position.coords.altitude,
                                altitudeAccuracy: position.coords.altitudeAccuracy,
                                heading: position.coords.heading,
                                speed: position.coords.speed,
                                timestamp: position.timestamp
                            }
                            this.updateBrowserDataPanel()
                        },
                        (error) => {
                            this.geolocationValue = { error: error.message }
                            this.updateBrowserDataPanel()
                        }
                    )
                } else {
                    this.geolocationValue = { error: 'Geolocation not supported' }
                }
            }

            async getBatteryInfo() {
                if (navigator.getBattery) {
                    try {
                        const battery = await navigator.getBattery()
                        this.batteryValue = {
                            charging: battery.charging,
                            chargingTime: battery.chargingTime,
                            dischargingTime: battery.dischargingTime,
                            level: battery.level
                        }
                        this.updateBrowserDataPanel()
                    } catch (e) {
                        this.batteryValue = { error: e.message }
                    }
                } else {
                    this.batteryValue = { error: 'Battery API not supported' }
                }
            }

            getSensorData() {
                const sensors = {}
                
                // Accelerometer
                if ('Accelerometer' in window) {
                    try {
                        const accelerometer = new Accelerometer()
                        accelerometer.addEventListener('reading', () => {
                            sensors.accelerometer = {
                                x: accelerometer.x,
                                y: accelerometer.y,
                                z: accelerometer.z
                            }
                            this.sensorsValue = sensors
                            this.updateBrowserDataPanel()
                        })
                        accelerometer.start()
                    } catch (e) {
                        sensors.accelerometer = { error: e.message }
                    }
                }
                
                // Gyroscope
                if ('Gyroscope' in window) {
                    try {
                        const gyroscope = new Gyroscope()
                        gyroscope.addEventListener('reading', () => {
                            sensors.gyroscope = {
                                x: gyroscope.x,
                                y: gyroscope.y,
                                z: gyroscope.z
                            }
                            this.sensorsValue = sensors
                            this.updateBrowserDataPanel()
                        })
                        gyroscope.start()
                    } catch (e) {
                        sensors.gyroscope = { error: e.message }
                    }
                }
                
                this.sensorsValue = sensors
            }

            async getNotificationStatus() {
                if ('Notification' in window) {
                    this.notificationsValue = {
                        permission: Notification.permission,
                        supported: true
                    }
                } else {
                    this.notificationsValue = { supported: false }
                }
            }

            async getClipboardInfo() {
                if (navigator.clipboard) {
                    this.clipboardValue = {
                        read: !!navigator.clipboard.read,
                        readText: !!navigator.clipboard.readText,
                        write: !!navigator.clipboard.write,
                        writeText: !!navigator.clipboard.writeText
                    }
                } else {
                    this.clipboardValue = { supported: false }
                }
            }

            getWebRTCInfo() {
                this.webRTCValue = {
                    getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                    RTCPeerConnection: !!window.RTCPeerConnection,
                    RTCSessionDescription: !!window.RTCSessionDescription,
                    RTCIceCandidate: !!window.RTCIceCandidate
                }
            }

            getWebAudioInfo() {
                this.webAudioValue = {
                    AudioContext: !!window.AudioContext,
                    OfflineAudioContext: !!window.OfflineAudioContext,
                    AudioWorklet: !!window.AudioWorklet
                }
            }

            getIndexedDBInfo() {
                this.indexedDBValue = {
                    supported: !!window.indexedDB,
                    databases: 'databases' in window.indexedDB
                }
            }

            getFileSystemInfo() {
                this.fileSystemValue = {
                    showOpenFilePicker: !!window.showOpenFilePicker,
                    showSaveFilePicker: !!window.showSaveFilePicker,
                    showDirectoryPicker: !!window.showDirectoryPicker
                }
            }

            getServiceWorkerInfo() {
                this.serviceWorkersValue = {
                    supported: 'serviceWorker' in navigator,
                    controller: !!navigator.serviceWorker.controller
                }
            }

            getWebWorkerInfo() {
                this.webWorkersValue = {
                    supported: !!window.Worker,
                    sharedWorker: !!window.SharedWorker
                }
            }

            updateBrowserDataPanel() {
                const panel = document.getElementById('browser-data-panel')
                if (!panel) return
                
                const data = {
                    cookies: Object.keys(this.cookiesValue).length,
                    localStorage: Object.keys(this.localStorageValue).length,
                    sessionStorage: Object.keys(this.sessionStorageValue).length,
                    device: this.deviceInfoValue,
                    network: this.networkInfoValue,
                    performance: this.performanceValue,
                    memory: this.memoryValue,
                    connection: this.connectionValue,
                    permissions: this.permissionsValue,
                    webGL: this.webGLValue,
                    mediaDevices: this.mediaDevicesValue,
                    geolocation: this.geolocationValue,
                    battery: this.batteryValue,
                    sensors: this.sensorsValue,
                    notifications: this.notificationsValue,
                    clipboard: this.clipboardValue,
                    webRTC: this.webRTCValue,
                    webAudio: this.webAudioValue,
                    indexedDB: this.indexedDBValue,
                    fileSystem: this.fileSystemValue,
                    serviceWorkers: this.serviceWorkersValue,
                    webWorkers: this.webWorkersValue
                }
                
                panel.innerHTML = `
                    <div class="text-lg font-bold mb-2 quantum-text">Browser Data Access</div>
                    <div class="grid grid-cols-2 gap-2 text-xs">
                        <div>Cookies: ${data.cookies}</div>
                        <div>LocalStorage: ${data.localStorage}</div>
                        <div>SessionStorage: ${data.sessionStorage}</div>
                        <div>Online: ${data.network.onLine}</div>
                        <div>WebGL: ${data.webGL.supported ? 'Yes' : 'No'}</div>
                        <div>Geolocation: ${data.geolocation.latitude ? 'Active' : 'Inactive'}</div>
                        <div>Battery: ${data.battery.level ? Math.round(data.battery.level * 100) + '%' : 'N/A'}</div>
                        <div>Memory: ${data.memory ? Math.round(data.memory.usedJSHeapSize / 1024 / 1024) + 'MB' : 'N/A'}</div>
                    </div>
                `
            }
        }

        // Register the controller
        const application = Stimulus.Application.start()
        application.register('universal-matrix', UniversalMatrixController)
    </script>
</body>
</html> 